[
  {
    "objectID": "slides.html#introduction",
    "href": "slides.html#introduction",
    "title": "Atelier D2E",
    "section": "Introduction",
    "text": "Introduction\nSur longue période, les institutions, les normes de sociétés ainsi que les comportements des agents économiques évoluent, induisant des changements dans la dynamique des séries économiques étudiées.\n\nDe nombreux modèles de l’Insee sont basés sur des régressions linéaires (CJO, prévisions, calage…) qui supposent que les relations entre les variables sont fixes dans le temps.\n\n\nHypothèse vraie sur le court-terme mais généralement fausse sur le long-terme ou en présence de changements structurels (changement de nomenclature, de définition, COVID…)\n\n\nObjectifs :\n\nétudier des méthodes qui permettent de relâcher cette contrainte ;\nproposer une façon simple d’implémenter et de comparer ces méthodes (package  tvCoef)"
  },
  {
    "objectID": "slides.html#modèle-de-régression-linéaire",
    "href": "slides.html#modèle-de-régression-linéaire",
    "title": "Atelier D2E",
    "section": "Modèle de régression linéaire",
    "text": "Modèle de régression linéaire\nIdée générale :\n\\[\n\\DeclareMathOperator{\\argmin}{argmin}\ny_t=\\beta_0+\\beta_1 x_{1,t}+\\dots+\\beta_p x_{p,t} +\\varepsilon_t\n\\]\n\\[\ny_t=\\beta X_t+\\varepsilon_t\n\\]\nEstimé grâce à la méthode des moindres carrés ordinaires\n\nExemple simple : prévision du PIB à partir du climat des affaires France (au mois 2) en niveau et en différence\n\\[\nPIB_t = \\beta_0 + \\beta_1 climat\\_fr_t + \\beta_2 \\Delta climat\\_fr_t + \\varepsilon_t\n\\]\n\n\nEstimation entre 2000 T1 et 2019 T4 :\n\\[\nPIB_t = -2,09 + 0,02 \\times climat\\_fr_t + 0,04 \\times \\Delta climat\\_fr_t + \\varepsilon_t\n\\]"
  },
  {
    "objectID": "slides.html#section",
    "href": "slides.html#section",
    "title": "Atelier D2E",
    "section": "",
    "text": "Deux types d’estimations : estimations dans l’échantillon et estimations en temps réel.\n\nDans l’échantillon : utilise toutes les données disponibles pour estimer les valeurs au sein de l’échantillon. Ce sont les valeurs ajustées qu’on obtient après une régression linéaire.\n\n\n\nEn temps réel : prévisions hors échantillon qui prévoient des valeurs en dehors d’un échantillon de données.\n Modèle estimé jusqu’à \\(t\\) pour effectuer la prévision de \\(t+1\\), puis on recommence en estimant le modèle jusqu’à \\(t+1\\).\n\n\n\nQualité des modèles évaluée par l’analyse des résidus et le calcul du RMSE (root mean square error) :\n\\[\n\\sqrt{\\frac{\\sum_{t=1}^{T} (PIB_t - \\widehat{PIB}_t)^2}{T}}\n\\]"
  },
  {
    "objectID": "slides.html#objectifs",
    "href": "slides.html#objectifs",
    "title": "Atelier D2E",
    "section": "Objectifs",
    "text": "Objectifs\nComparer différentes méthodes pour modéliser et estimer :\n\\[\nPIB_t = \\beta_{0,t} + \\beta_{1,t} climat\\_fr_t + \\beta_{2,t} \\Delta climat\\_fr_t + \\varepsilon_t\n\\]\nIdée : rester proche du cas de la régression linéaire pour que les résultats restent facilement interprétables.\n\nPlan :\n\nLes tests statistiques étudiés\nLes régressions par morceaux\nLes régressions locales\nLes modèles espace-état\nQuelques résultats généraux"
  },
  {
    "objectID": "slides.html#tests-statistiques-bai-et-perron",
    "href": "slides.html#tests-statistiques-bai-et-perron",
    "title": "Atelier D2E",
    "section": "Tests statistiques : Bai et Perron",
    "text": "Tests statistiques : Bai et Perron\nOn cherche à savoir si les coefficients sont stables au cours du temps.\nBai et Perron s’appuie sur le test de Chow. Proposent un algorithme efficace pour trouver les dates de ruptures (package strucchange). Soit le modèle :\n\\[\nPIB_t = \\beta_0 + \\beta_1 climat\\_fr_t + \\beta_2 \\Delta climat\\_fr_t + \\varepsilon_t\n\\]\n\nOn le sépare en deux, autour d’une date \\(t_1\\), et on obtient deux sous-modèles :\n\\[\n\\forall t \\leq t_1 :\\quad PIB_t = \\beta_0' + \\beta_1' climat\\_fr_t + \\beta_2' \\Delta climat\\_fr_t + \\varepsilon_t\n\\]\n\\[\n\\forall t &gt; t_1 :\\quad PIB_t = \\beta_0'' + \\beta_1'' climat\\_fr_t + \\beta_2'' \\Delta climat\\_fr_t + \\varepsilon_t\n\\]\nL’hypothèse nulle suppose que \\(\\beta_0' = \\beta_0''\\), \\(\\beta_1' = \\beta_1''\\) et \\(\\beta_2' = \\beta_2''\\). Autrement dit, on teste si les deux modèles obtenus sont significativement différents."
  },
  {
    "objectID": "slides.html#limites-de-bai-perron",
    "href": "slides.html#limites-de-bai-perron",
    "title": "Atelier D2E",
    "section": "Limites de Bai Perron",
    "text": "Limites de Bai Perron\n\nLa rupture peut n’être que sur un sous-ensemble de variables, mais le test ne s’applique que sur l’ensemble d’un modèle\n\n\nOn teste :\n\\[\nPIB_t = (\\beta_{0} + \\beta_{1} climat\\_fr_t + \\beta_{2} \\Delta climat\\_fr_t) \\mathbb 1_{t \\leq t_1} +\n\\\\\n(\\beta_{0}' + \\beta_{1}' climat\\_fr_t + \\beta_{2}' \\Delta climat\\_fr_t)\\mathbb 1_{t &gt; t_1} +\n\\varepsilon_t\n\\]\nOn ne peut pas tester :\n\\[\nPIB_t = \\beta_{0} + \\beta_{1} climat\\_fr_t + (\\beta_{2} \\mathbb 1_{t \\leq t_1}+ \\beta_{2}' \\mathbb 1_{t &gt; t_1})\\Delta climat\\_fr_t +\n\\varepsilon_t\n\\]\n\n\n\nInstabilité sur le choix de la date et la rupture n’est pas forcément brutale (ex : évolution lente dans le temps)\n\n\n\nMais ces tests supposent qu’il existe une date de rupture à déterminer, alors que l’on veut parfois juste savoir si les coefficients sont constants ou non."
  },
  {
    "objectID": "slides.html#nyblom-et-hansen",
    "href": "slides.html#nyblom-et-hansen",
    "title": "Atelier D2E",
    "section": "Nyblom et Hansen",
    "text": "Nyblom et Hansen\nTests trouvés dans la littérature autour de Nyblom et Hansen (1992) : sous  tvCoef::hansen.test() \\[\n\\begin{cases}\n(H_0):&\\text{coefficients constants} \\\\\n(H_1):&\\text{coefficients suivent une martingale}\n\\end{cases}\n\\]\n\nLimites de Hansen :\n\nTest de la l’instabilité de la variance (passer par d’autres tests)\nTest joint ne s’applique pas aux indicatrices\nNe s’applique que sur les variables stationnaires\n\n\n\n Comme tout test, ils ont leurs limites, prendre les résultats avec précaution.\nEx : même si le test de Hansen ne détecte pas d’instabilité, le test de Bai et Perron peut néanmoins détecter des ruptures."
  },
  {
    "objectID": "slides.html#régressions-linéaires-par-morceaux",
    "href": "slides.html#régressions-linéaires-par-morceaux",
    "title": "Atelier D2E",
    "section": "Régressions linéaires par morceaux",
    "text": "Régressions linéaires par morceaux\nModèles les plus simples :\n\\[\n\\exists t_1,\\dots,t_{T-1}:\\:\n\\beta_t = \\beta_1\\mathbb 1_{t \\leq t_1} + \\beta_2 \\mathbb 1_{t_1 &lt; t \\leq t_2} + \\dots + \\beta_T \\mathbb 1_{t_{T-1} &lt; t}\n\\]\n\nS’estiment en :\n\nDécoupant les régresseurs (\\(\\mathbb V[\\varepsilon_t]\\) fixe dans le temps)\n tvCoef::piece_reg()\nOu en faisant des régressions linéaires par morceaux (\\(\\mathbb V[\\varepsilon_t]\\) varie par sous-période)\n tvCoef::bp.lms()\n\n\n\n utilisation du cas 1 car donne une seule régression en sortie.\nDans les deux cas estimations de coefficients restent les mêmes. Différences : sur les variances et sur les estimations en temps réel."
  },
  {
    "objectID": "slides.html#section-4",
    "href": "slides.html#section-4",
    "title": "Atelier D2E",
    "section": "",
    "text": "Avantages :\n\nSimples à comprendre et à implémenter\nFacilement combinable avec d’autres types de modèles (régressions locales)\n\n\n Inconvénients :\n\nSuppose l’existence une rupture brutale\nImprécisions dans le choix de la date\n\n\n\nDans le cas de notre modèle exemple, Bai et Perron détecte une rupture en 2011 T1. Le modèle suivant est donc estimé :\n\\[\nPIB_t = (\\beta_{0,t}+ \\beta_{1,t}climat\\_fr_t + \\beta_{2,t} \\Delta climat\\_fr_t) \\mathbb{1} _{t \\leq 2011} +\n\\\\\n(\\beta_{0,t} + \\beta_{1,t} climat\\_fr_t + \\beta_{2,t} \\Delta climat\\_fr_t) 1_{t &gt; 2011} + \\varepsilon_t\n\\]\n\n\nCe qui donne :\n\\[\nPIB_t = (-2,9+ 0,03 \\times climat\\_fr_t + 0,07 \\times \\Delta climat\\_fr_t) \\mathbb{1} _{t \\leq 2011} +\n\\\\\n(-1,04 + 0,01 \\times climat\\_fr_t - 0,01 \\times \\Delta climat\\_fr_t) 1_{t &gt; 2011} + \\varepsilon_t\n\\]"
  },
  {
    "objectID": "slides.html#régressions-locales-fa-brands-r-project-tvreg",
    "href": "slides.html#régressions-locales-fa-brands-r-project-tvreg",
    "title": "Atelier D2E",
    "section": "Régressions locales :  tvreg",
    "text": "Régressions locales :  tvreg\nHypothèse \\(\\beta_t = \\beta(z_t)\\) avec par défaut \\(z_t = t/T\\) et \\(\\beta()\\) localement constante (Nadaraya-Watson) ou localement linéaire.\n\nEstimation : \\[\n\\beta(z_t) = \\underset{\\theta_0}{\\argmin}\\sum_{j=1}^T\\left(y_{j}-x_j\\theta_0\\right)^2K_b(z_j-z_t)\n\\] Avec \\(K_b(x)=\\frac 1 b K(x/b)\\) une fonction de noyau pour pondérer les observations.\n\n\nRemarque :\n\nSi \\(b\\geq1\\) on utilise toutes les données pour chaque estimation.\n\nSi \\(b=20\\) le poids donné à toutes les données se rapproche de 1, estimation \\(\\simeq\\) à la régression linéaire"
  },
  {
    "objectID": "slides.html#section-8",
    "href": "slides.html#section-8",
    "title": "Atelier D2E",
    "section": "",
    "text": "Inconvénient :\n\nTous les coefficients varient\n\nProblème du choix de \\(b\\) : par validation croisée (entre 0 et 20) mais peu discriminant\n\nFortes révisions possibles en temps-réel : ajout d’un point, changement de b, noyau asymétrique\n\n\nRemarque :\n\nPossibilité de combiner les précédents modèles en estimant une régression locale sur des données coupées\nEn effectuer deux régression, on peut fixer les coefficients de certaines variables."
  },
  {
    "objectID": "slides.html#modèles-espace-état",
    "href": "slides.html#modèles-espace-état",
    "title": "Atelier D2E",
    "section": "Modèles espace-état",
    "text": "Modèles espace-état\nModélisation espace-état est une méthodologie générale qui permet de traiter un grand nombre de problèmes de séries temporelle.\n\nHypothèse : problème déterminé par une série de vecteurs non observés \\(\\alpha_1,\\dots,\\alpha_n\\) associés aux observations \\(y_1,\\dots,y_n\\), la relation entre \\(\\alpha_t\\) et \\(y_t\\) étant spécifiée par le modèle espace-état.\n\n\nPlusieurs formes de modèles sont possibles, les plus simples étant les modèles linéaires gaussiens.\nVersion simplifiée :\n\\[\n\\begin{cases}\ny_t=X_t\\alpha_t+\\varepsilon_t,\\quad&\\varepsilon_t\\sim\\mathcal N(0,\\sigma^2)\\\\\n\\alpha_{t+1}=\\alpha_t+\\eta_t,\\quad&\\eta_t\\sim\\mathcal N(0,\\sigma^2 Q)\n\\end{cases},\\text{ avec }\\eta_t\\text{ et }\\varepsilon_t\\text{ indépendants}\n\\]\navec \\(y_t\\) de dimension \\(p\\times 1\\) vecteur des observations, et \\(\\alpha_t\\) de dimension \\(m \\times 1\\) vecteur d’états (state vector).\n\n\n\\(\\sigma^2\\) un facteur simplifiant les estimations (Concentration of loglikelihood)."
  },
  {
    "objectID": "slides.html#retour-sur-la-régression-linéaire",
    "href": "slides.html#retour-sur-la-régression-linéaire",
    "title": "Atelier D2E",
    "section": "Retour sur la régression linéaire",
    "text": "Retour sur la régression linéaire\nRégression linéaire : \\[\n\\begin{cases}\ny_t=X_t\\alpha+\\varepsilon_t,\\quad&\\varepsilon_t\\sim\\mathcal N(0,\\sigma^2)\\\\\n\\alpha_{t+1}=\\alpha_t=\\dots=\\alpha_0=\\alpha\n\\end{cases}\n\\] C’est-à-dire : \\[\nPIB_t = \\beta_0 + \\beta_1 climat\\_fr_t + \\beta_2 \\Delta climat\\_fr_t + \\varepsilon_t\n\\] Devient : \\[\nPIB_t=\\begin{pmatrix}1 & climat\\_fr & \\Delta climat\\_fr\\end{pmatrix}_t\n\\begin{pmatrix}\n\\beta_0 \\\\\n\\beta_1 \\\\\n\\beta_2\n\\end{pmatrix} + \\varepsilon_t\n\\]"
  },
  {
    "objectID": "slides.html#estimation-par-filtre-de-kalman",
    "href": "slides.html#estimation-par-filtre-de-kalman",
    "title": "Atelier D2E",
    "section": "Estimation par filtre de Kalman",
    "text": "Estimation par filtre de Kalman\nDeux opérations classiques : filtering et smoothing\n\nSmoothing : estime le coefficient à chaque date grâce à toute l’information disponible. Ce qui est proche des estimations dans l’échantillon.\n\n\\[\n\\hat\\alpha_t = E[\\alpha_t|y_0, \\dots, y_n]\n\\] Ex : régression linéaire : \\(\\hat\\alpha_t = \\hat \\alpha\\)\n\n\nFiltering : estime le coefficient suivant (en \\(t+1\\)) avec les informations connues en \\(t\\). Ce qui est proche des estimations en temps-réel.\n\n\\[\na_{t+1} = E[\\alpha_{t+1}|y_0, \\dots, y_t]\n\\]\nEx : régression linéaire : \\(a_{2010T2} = \\hat \\alpha\\) estimé en utilisant les données jusqu’en 2010T1"
  },
  {
    "objectID": "slides.html#résultats",
    "href": "slides.html#résultats",
    "title": "Atelier D2E",
    "section": "Résultats",
    "text": "Résultats\nEtude de 25 modèles de prévision de la production manufacturière estimés entre 1990 T1 et 2019 T4. On estime les différents modèles présentés dans l’échantillon et en temps réel, puis on compare les RMSE des modèles par rapport au modèle linéaire. Enfin on fait des moyennes par secteur.\n\nOn obtient les résultats suivants pour les estimations dans l’échantillon :\n\n\n\n\n\n\nReg linéaire\nEspace état\nReg morceaux\nReg locale + morceaux\nReg locale\n\n\n\n\nmodel_c1 (7)\n1\n0,97\n1,00\n1,00\n1,00\n\n\nmodel_c3 (5)\n1\n0,85\n0,93\n0,90\n0,94\n\n\nmodel_c4 (5)\n1\n0,81\n0,96\n0,90\n0,90\n\n\nmodel_c5 (5)\n1\n0,75\n0,80\n0,78\n0,78\n\n\nmodel_manuf (3)\n1\n0,96\n0,99\n0,97\n0,98\n\n\n\n\n\n\n\n\n\nLa plupart des modèles sont généralement meilleurs que le modèle linéaire."
  },
  {
    "objectID": "slides.html#section-16",
    "href": "slides.html#section-16",
    "title": "Atelier D2E",
    "section": "",
    "text": "Et en temps réel :\n\n\n\n\n\n\nReg linéaire\nEspace état\nReg morceaux\nReg locale + morceaux\nReg locale\n\n\n\n\nmodel_c1 (7)\n1\n0,99\n1,00\n1,00\n1,00\n\n\nmodel_c3 (5)\n1\n0,91\n2,73\n2,74\n0,99\n\n\nmodel_c4 (5)\n1\n0,92\n5,13\n5,19\n1,06\n\n\nmodel_c5 (5)\n1\n0,87\n2,58\n2,75\n1,26\n\n\nmodel_manuf (3)\n1\n0,96\n1,01\n1,03\n1,00\n\n\n\n\n\n\n\n\nLes modèles espace-état sont meilleurs que le modèle linéaire en terme de RMSE pour la prévision en temps réel. Pour ce qui est des autres modèles, plus variable d’un modèle à l’autre."
  },
  {
    "objectID": "slides.html#conclusion",
    "href": "slides.html#conclusion",
    "title": "Atelier D2E",
    "section": "Conclusion",
    "text": "Conclusion\n\nDe nombreux modèles peuvent être estimés autour des régressions linéaires : le cadre reste simple mais la modélisation est plus complexe\n choix de modélisations doivent être faits\n\n\n\nMême s’ils peuvent améliorer les performances des modèles « classiques » ils ne les remplacent pas pour autant\n\n\n\n\nModèles parfois complexes à implémenter (notamment espace-état)\n tvCoef peut vous aider (https://github.com/AQLT/tvCoef)"
  },
  {
    "objectID": "slides.html#à-venir",
    "href": "slides.html#à-venir",
    "title": "Atelier D2E",
    "section": "À venir",
    "text": "À venir\nCourt-terme : pause de 10/15 minutes suivie d’un atelier pratique :\nhttps://aqlt.github.io/AteliertvCoef/\nSur tvCoef : documentation, gestion des retards de la variable endogène, amélioration des estimations en temps réel autour de la date de rupture des régressions par morceaux\nAutour cette l’étude : séminaire D2E + document de travail\nAutres études : analyse de ces méthodes pour la CJO"
  },
  {
    "objectID": "TP.html",
    "href": "TP.html",
    "title": "Utilisation de modèles de régression à coefficients variant dans le temps pour la prévision conjoncturelle",
    "section": "",
    "text": "L’objectif de ce TP est d’apprendre à utiliser quelques fonctionnalités du package tvCoef pour l’estimation de modèles de régression à coefficients variant dans le temps.\nLes packages suivants seront utilisés :\npackages_to_install &lt;- c(\"dygraphs\", \"car\", \"dynlm\")\n\npackages &lt;- installed.packages()[,\"Package\"][! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) &gt; 0) {\n    install.packages(packages)\n}\nif (\"tvCoef\" %in% installed.packages()[,\"Package\"]) {\n  remotes::install_github(\"palatej/rjd3toolkit\")\n  remotes::install_github(\"palatej/rjd3sts\")\n  remotes::install_github(\"AQLT/tvCoef\")\n}\nPour l’installation de tvCoef, voir le manuel d’installation.\nPour ce TP nous utiliserons les données de la base tvCoef::manufacturingpour prévoir l’évolution trimestrielle de la production du secteur des autres industries manufacturières (C5, prod_c5) à partir de :\nLes deux dernières variables sont utilisées en différence.\nPar simplification, nous estimerons ici le modèle entre le 1993T1 et 2019T4 : pour estimer le modèle au-delà cette date, il faudrait ajouter des indicatrices au cours de l’année 2020 et vérifier si le modèle estimé est toujours bien spécifié.\nLe modèle peut alors être estimé en utilisant par exemple la fonction dynlm::dynlm()1 :\nlibrary(tvCoef)\nlibrary(dynlm)\ndata &lt;- window(manufacturing, start = 1993, end = c(2019, 4))\ny &lt;- data[, \"prod_c5\"]\nmodel_c5 &lt;- dynlm(\n  formula = prod_c5 ~ overhang_ipi1_c5 + insee_bc_c5_m3 + insee_oscd_c5_m2\n  + diff(insee_tppre_c5_m3, 1) + diff(bdf_tuc_c5_m2, 1),\n  data = data\n)\nmodel_c5\n\n\nTime series regression with \"ts\" data:\nStart = 1993(2), End = 2019(4)\n\nCall:\ndynlm(formula = prod_c5 ~ overhang_ipi1_c5 + insee_bc_c5_m3 + \n    insee_oscd_c5_m2 + diff(insee_tppre_c5_m3, 1) + diff(bdf_tuc_c5_m2, \n    1), data = data)\n\nCoefficients:\n               (Intercept)            overhang_ipi1_c5  \n                 -15.94185                     0.12222  \n            insee_bc_c5_m3            insee_oscd_c5_m2  \n                   0.14891                    -0.04347  \ndiff(insee_tppre_c5_m3, 1)      diff(bdf_tuc_c5_m2, 1)  \n                   0.03711                     0.01846\nLes prévisions dans l’échantillon (in sample) peuvent être extrait avec les fonctions fitted() ou predict() et les prévisions en temps-réel (out of sample) avec la fonction tvCoef::oos_prev().\nPour évaluer la qualité en temps-réel, nous utiliserons les résidus à partir de 2000 :\nprev_oos_lm &lt;- oos_prev(model_c5)\nres_lm_is &lt;- residuals(model_c5)\nres_lm_oos &lt;- prev_oos_lm$residuals\nrmse_lm &lt;- c(IS = rmse(res_lm_is), OOS = rmse(res_lm_oos))\nrmse_lm\n\n       IS       OOS \n0.7656267 0.9298085\nPour tracer les prévisions, on peut utiliser la fonction plot() :\nplot(window(y, start = 2000))\nlines(prev_oos_lm$prevision, col = \"red\")\nlegend(\"bottomleft\", legend = c(\"y\",\"Prev. temps réel\"),\n       col= c(\"black\", \"red\"), lty = 1)"
  },
  {
    "objectID": "TP.html#remarque",
    "href": "TP.html#remarque",
    "title": "Utilisation de modèles de régression à coefficients variant dans le temps pour la prévision conjoncturelle",
    "section": "2.1 Remarque",
    "text": "2.1 Remarque\nPour fixer certaines variables, on pourrait faire une régression en deux étapes. La fonction rmse_prev() permet de calculer les prévisions dans l’échantillon et hors échantillon sur le modèle de régression linéaire, la régression par morceaux, la régression locale en fixant ou non certains coefficients.\n\ncomp_prev &lt;- rmse_prev(model_c5, fixed_var = c(3, 4, 5, 6), fixed_bw = TRUE)\n\nCalculating regression bandwidth... bw =  0.3066338 \nCalculating regression bandwidth... bw =  0.2701166 \n\ncomp_prev\n\n                       RMSE_in_sample RMSE_out_of_sample\nlm                          0.7656267          0.9298085\npiece_lm                    0.6008502          1.5042050\npiece_lm fixed coeff        0.6364012          1.4565471\nTvLM                        0.5601224          1.1195514\npiece_tvlm                  0.5043489          1.6177417\npiece_tvlm fixed coeff      0.5127197          2.6673561\nTvLM fixed coeff            0.6509789          0.8886024\n\n\nSept modèles différents sont estimés, dans l’ordre :\n\nModèle de régression linéaire.\nRégression linéaire par morceaux où toutes les variables divisées en fonction de la date de rupture.\nRégression linéaire par morceaux où toutes les variables, sauf celles spécifiées par fixed_var, sont divisées en fonction de la date de rupture.\nRégression locale.\nRégression locale avec toutes les variables divisées en fonction de la date de rupture.\nRégression locale où toutes les variables, sauf celles spécifiées par fixed_var, sont divisées en fonction de la date de rupture.\nRégression locale où les variables celles spécifiées par fixed_var sont estimées par une régression linéaire (coefficients fixes sur l’ensemble de la période).\n\nOn peut ensuite récupérer tous les résidus en temps réel :\n\ncomp_prev_tr &lt;- do.call(cbind, lapply(comp_prev$prevision, `[[`, \"residuals\"))\napply(window(comp_prev_tr, start = 2010), 2, rmse)\n\n             prev_lm        prev_piece_lm   prev_piece_lm_fixe \n           0.7431644            0.9633194            0.7018949 \n           prev_tvlm      prev_piece_tvlm prev_piece_tvlm_fixe \n           0.7904943            0.9564709            0.7897816 \n      prev_tvlm_fixe \n           0.6568764"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Utilisation de modèles de régression à coefficients variant dans le temps pour la prévision conjoncturelle",
    "section": "",
    "text": "Ce site web contient l’ensemble des documents utilisés pendant l’atelier D2E du 16 mars 2023 sur l’utilisation de modèles de régression à coefficients variant dans le temps pour la prévision conjoncturelle.\nVous y trouverez les slides ainsi que le TP.\nPour le TP, vous pouvez soit utiliser le datalab en cliquant ici  soit installer localement les packages en suivant le manuel d’installation."
  },
  {
    "objectID": "manuel_installation.html",
    "href": "manuel_installation.html",
    "title": "Installation de tvCoef",
    "section": "",
    "text": "Pour utiliser tvCoef, il faut il faut avoir la version 17 de Java (ou une version supérieure).\nPour savoir quelle version de Java est utilisée par R, utiliser le code suivant :\n\nlibrary(rJava)\n.jinit()\n.jcall(\"java/lang/System\", \"S\", \"getProperty\", \"java.runtime.version\")\n\n[1] \"18+36-2087\"\n\n\nSi le résultat n’est pas sous la forme \"17xxxx\" c’est que vous n’avez pas Java 17 !\nSi l’on a pas cette version d’installée et que l’on n’a pas les droits d’administrateur pour installer Java il faut alors installer une version portable de Java. Pour installer une version portable de java, télécharger par exemple le fichier Windows 10 x64 Java Development Kit disponible sur https://jdk.java.net/java-se-ri/17, le dézipper et le mettre par exemple sous \"D:/Programmes/jdk-17\".\nPour configurer R avec une version portable de Java, trois solutions :\n\nAvant avant tout chargement de package nécessitant Java (rJava…) (si vous avez lancé le code précédent, relancez donc R) :\n\n\nSys.setenv(JAVA_HOME='D:/Programmes/jdk-17')\n\n\nPour éviter de faire cette manipulation à chaque fois que l’on relance R, deux solutions :\n\nmodifier le JAVA_HOME dans les variables d’environnement de Windows (voir https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html).\nmodifier le .Renviron : depuis R lancer le code file.edit(\"~/.Renviron\"), ajouter dans le fichier le chemin vers la version portable de Java comme précédemment (JAVA_HOME='D:/Programmes/jdk-17'), sauvegarder et relancer R.\n\n\nIl reste maintenant à installer les packages :\n\nremotes::install_github(\"palatej/rjd3toolkit\")\nremotes::install_github(\"palatej/rjd3sts\")\nremotes::install_github(\"AQLT/tvCoef\")\n\nSi vous utilisez un ordinateur professionnel, pensez à configurer le proxy pour que ces commandes puissent fonctionner (voir https://www.book.utilitr.org/01_r_insee/fiche-personnaliser-r#le-fichier-.renviron). Pour cela vous pouvez utiliser curl::ie_get_proxy_for_url() pour récupérer l’adresse du proxy et ajouter deux variable http_proxy et https_proxy dans les variables d’environnement."
  }
]